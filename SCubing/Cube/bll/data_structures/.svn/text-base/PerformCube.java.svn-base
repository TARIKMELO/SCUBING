package bll.data_structures;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map.Entry;

import org.geotools.data.FeatureSource;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;

import presentation.layout.MapFrame;
import bll.data_structures.nodes.DimensionTypeValue;
import bll.data_structures.nodes.MeasureTypeValue;
import bll.data_structures.nodes.NodeSimple;
import bll.parallel.ResourceII;
import dal.drivers.CubeColumn;
import dal.drivers.IResultSetText;
import dal.drivers.ShapeFileReader;
import dal.drivers.ShapeFileWriter;

public class PerformCube<N extends NodeSimple<DimensionTypeValue>> {

	private FeatureSource<SimpleFeatureType, SimpleFeature> CreateCube(HashMap<String, CubeColumn> cubeColumns, int x, int y, FeatureSource<SimpleFeatureType, SimpleFeature> featureSource) throws Exception{
		long inicioTotal = System.currentTimeMillis();  

		long inicio = System.currentTimeMillis();  

		//conectar
		//IConnection<String> umaConexao = new ConnectionText<String>();
		ShapeFileReader<DimensionTypeValue> shapeFileReader = new ShapeFileReader<DimensionTypeValue>(featureSource,cubeColumns);
		IResultSetText<DimensionTypeValue> rs = shapeFileReader.getData();
		ICubeSimple<DimensionTypeValue> cube = createBaseCuboide(rs, cubeColumns);
		//cubeGrid.performHierarchies(x,y,rs, shapeFileReader.getSource(),cubeColumns);
		cube.generateAggregations();
		//System.err.println("numero de nos : " + cube.countNumofNodes());	
		//Lista de dimensoes com lista de medidas
		//HashMap<ArrayList<DimensionTypeValue>, ArrayList<MeasureTypeValue>> hashResult = cube.cubeToTable();
		ResourceII<Entry <ArrayList<DimensionTypeValue>, ArrayList<MeasureTypeValue>>> resource= cube.cubeToTable();
		//Imprimindo o cubo resultante
		/*	for (ArrayList<DimensionTypeValue> dimensions : hashResult.keySet()) {
			System.out.println(dimensions+ " " + hashResult.get(dimensions)) ;
		}*/
		long end = System.currentTimeMillis(); 
		System.err.println("Tempo agregações alfa numérica: " + ((end - inicio) / 1000) + " segundos");
		inicio = System.currentTimeMillis();  
		//shapeFileWriter.connect();
		ShapeFileWriter shapeFileWriter = new ShapeFileWriter(cubeColumns);
		//FeatureSource sourceDesti = shapeFileWriter.insertCubeToSource(hashResult, shapeFileReader.getSource());
		FeatureSource<SimpleFeatureType, SimpleFeature> sourceDesti = shapeFileWriter.insertCubeToSource(resource, shapeFileReader.getSource());
		//shapeFileWriter.insertCubeToShapefile(hashResult, sourceDesti,"D:\\data\\CuboFinal"+sourceDesti.getFeatures().size()+".shp");

		end = System.currentTimeMillis(); 
		System.err.println("Tempo aplicar função agregação espacial: " + ((end - inicio) ) + " ms");

		long endTotal = System.currentTimeMillis(); 
		System.err.println("Tempo Total: " + ((endTotal - inicioTotal) ) + " ms");


		//JOptionPane.showMessageDialog(null, "O tempo total é de: "+((endTotal - inicioTotal)));
		//Retorna e depois vai ser transformado em layer
		return sourceDesti;
	}

	public ICubeSimple<DimensionTypeValue> createBaseCuboide(IResultSetText<DimensionTypeValue> rs,HashMap<String, CubeColumn> cubeColumns )
	{

		//TODO: Olhar o padrao adapter para colocar o nome da coluna ao invés do indice
		//-1 por causa da coluna que é a medida
		ICubeSimple<DimensionTypeValue> cube = new CubeSimple<DimensionTypeValue>(cubeColumns,cubeColumns.size());


		Object[] tuple;
		ArrayList<MeasureTypeValue>  measures;
		String measureValue;
		while((tuple=rs.next())!=null){

			measures = new ArrayList<MeasureTypeValue>();
			for (Entry<String, CubeColumn> cubeColumn: cubeColumns.entrySet())
			{
				if(cubeColumn.getValue().isMeasure())
				{
					//measures = new ArrayList<MeasureTypeValue>();
					measureValue = tuple[cubeColumn.getValue().getIndex()].toString().trim();
					measures.add(new MeasureTypeValue(  measureValue,cubeColumn.getValue().getColumnName()));
				}
			}
			for (Entry<String, CubeColumn> cubeColumn: cubeColumns.entrySet())
			{
				if(!cubeColumn.getValue().isMeasure())
				{
					Object attributeO = tuple[cubeColumn.getValue().getIndex()];
					String attribute = attributeO.toString();
					DimensionTypeValue typeValu = new DimensionTypeValue(attribute, cubeColumn.getKey());
					NodeSimple<DimensionTypeValue> n = cube.findNode(typeValu);
					if(n == null){
						n = new NodeSimple<DimensionTypeValue>(cubeColumns, measures);
						cube.insertNode(typeValu, n);
					}
					else
					{


						n.updateMeasure(measures);
					}
				}
			}
			cube.refresh();
		}

		return cube;
	}

	public void gerarCubo(HashMap<String, CubeColumn> cubeColumns, FeatureSource<SimpleFeatureType, SimpleFeature> featureSource) 
	{
		HashMap<Integer, ArrayList<CubeColumn> > hierarquias = new HashMap<Integer, ArrayList<CubeColumn> >();
		try
		{
			final HashMap<String, CubeColumn> commonCubeColumns = new HashMap<String, CubeColumn>();
			for (CubeColumn cubeColumn : cubeColumns.values()) {
				if (cubeColumn.isMeasure()||cubeColumn.getHierarchy()==-1)
				{
					commonCubeColumns.put(cubeColumn.getColumnName(), cubeColumn);
				}

			}


			for (CubeColumn cubeColumn : cubeColumns.values()) {
				if (!cubeColumn.isMeasure())
				{
					if (cubeColumn.getHierarchy()!=-1){

						if (hierarquias.get(cubeColumn.getHierarchy())==null)
						{
							hierarquias.put(cubeColumn.getHierarchy(),new ArrayList<CubeColumn>()); 
							hierarquias.get(cubeColumn.getHierarchy()).addAll(commonCubeColumns.values());
						}
						hierarquias.get(cubeColumn.getHierarchy()).add(cubeColumn);
					}
				}
			}

			//Deepy Copy
			HashMap<String, CubeColumn> cubeColumnsAux = new HashMap<String, CubeColumn>();
			//TODO: Modularizar isso melhor
			long inicio = System.currentTimeMillis();  
			for (ArrayList<CubeColumn> cubeColumnList : hierarquias.values()) {
				int auxT = 0;
				for (CubeColumn cubeColumn : cubeColumnList) {
					cubeColumn.setIndex(auxT);
					auxT++;
					cubeColumnsAux.put(cubeColumn.getColumnName(), cubeColumn);
				}
				try {
					//PerformCube performCube = new PerformCube();
					FeatureSource<SimpleFeatureType, SimpleFeature> sourceDesti;
					sourceDesti = CreateCube(cubeColumnsAux,0 ,0, featureSource);
					MapFrame.getInstance().createLayer(sourceDesti);
					cubeColumnsAux = new HashMap<String, CubeColumn>();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}

			long end = System.currentTimeMillis(); 
			System.err.println("Tempo Total: " + ((end - inicio) / 1000) + " segundos");
		}
		catch(Exception ioEx){
			//textAreaStatus.setText("Cubo gerado com sucesso!");
			ioEx.printStackTrace();
		}
	}

}
